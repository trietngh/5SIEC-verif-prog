import subprocess
import re
import time
import csv
import matplotlib.pyplot as plt
import sys
import os

# --- CONFIGURATION ---
# Replace 'script.c' with your actual C file name
C_FILE = "*.c" 

# SLEVEL Loop Configuration
SLEVEL_START = 0
SLEVEL_END = 10000
SLEVEL_STEP = 500   # Checking every 500 levels (0, 500, 1000...)
SLEVEL_LIST = [0, 50, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000]

OUTPUT_CSV = "frama_c_results.csv"
OUTPUT_IMAGE = "framac_analysis_plot.png"

# Base command structure
# Note: We use Python to measure time, so 'time' command is removed from the string.
# The {slevel} and {c_file} placeholders will be filled dynamically.
BASE_CMD = (
    "frama-c -lib-entry -absolute-valid-range 0-0xFFFFFFFF "
    "-metrics-value-cover -eva -pp-annot "
    "-cpp-command \"gcc -C -E -DLINUX -LRobotSeeVM_v0001\" "
    "{c_file} -slevel {slevel}"
)

def parse_frama_c_output(output):
    """
    Parses Frama-C stdout/stderr to extract Alarms and Coverage percentage.
    """
    
    # --- 1. Parse Alarms ---
    # Standard Frama-C output: "[eva] ... 5 alarms generated by the analysis"
    alarm_pattern = r"(\d+)\s+alarms\s+generated\s+by\s+the\s+analysis"
    alarm_match = re.search(alarm_pattern, output)
    
    if alarm_match:
        alarms = int(alarm_match.group(1))
    else:
        # Fallback: Count explicitly labelled alarms if summary is missing
        alarms = output.count("[eva:alarm]")

    # --- 2. Parse Coverage ---
    # Target format: "  441 stmts in analyzed functions, 428 stmts analyzed (97.1%)"
    # We look for the pattern "stmts analyzed (X.X%)"
    coverage_pattern = r"stmts analyzed \(([\d\.]+)%\)"
    coverage_match = re.search(coverage_pattern, output)
    
    if coverage_match:
        coverage = float(coverage_match.group(1))
    else:
        coverage = 0.0 # Default if not found

    return alarms, coverage

def run_analysis(slevel):
    """
    Runs the Frama-C command for a specific slevel and captures metrics.
    """
    cmd = BASE_CMD.format(c_file=C_FILE, slevel=slevel)
    
    print(f"Running slevel {slevel}...", end=" ", flush=True)
    start_time = time.time()
    
    try:
        # Run the command
        # capture_output=True captures both stdout and stderr
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True
        )
        
        elapsed_time = time.time() - start_time
        
        # Combine stdout and stderr for parsing (Frama-C writes to both)
        full_output = result.stdout + result.stderr
        
        alarms, coverage = parse_frama_c_output(full_output)
        
        print(f"Done ({elapsed_time:.2f}s) -> Alarms: {alarms}, Cov: {coverage}%")
        return elapsed_time, alarms, coverage

    except Exception as e:
        print(f"\nError executing slevel {slevel}: {e}")
        return 0, 0, 0

def plot_results(results):
    """
    Generates a 3-panel plot from the collected data.
    """
    if not results:
        print("No results to plot.")
        return

    slevels = [r['slevel'] for r in results]
    times = [r['time'] for r in results]
    alarms = [r['alarms'] for r in results]
    coverages = [r['coverage'] for r in results]

    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12), sharex=True)

    # Plot 1: Time
    ax1.plot(slevels, times, marker='o', color='tab:blue')
    ax1.set_ylabel('Execution Time (s)')
    ax1.set_title(f'Frama-C Analysis: Slevel Impact ({C_FILE})')
    ax1.grid(True, linestyle='--', alpha=0.7)

    # Plot 2: Alarms
    ax2.plot(slevels, alarms, marker='s', color='tab:red')
    ax2.set_ylabel('Alarms Generated')
    ax2.grid(True, linestyle='--', alpha=0.7)

    # Plot 3: Coverage
    ax3.plot(slevels, coverages, marker='^', color='tab:green')
    ax3.set_ylabel('Coverage (%)')
    ax3.set_xlabel('Slevel Parameter')
    ax3.grid(True, linestyle='--', alpha=0.7)

    plt.tight_layout()
    plt.savefig(OUTPUT_IMAGE)
    print(f"\nPlot saved to {OUTPUT_IMAGE}")
    # plt.show() # Uncomment if you want the window to pop up

def main():
    # Check if the C file actually exists to prevent immediate failure
    # if not os.path.exists(C_FILE):
    #     print(f"Error: File {C_FILE} not found.")
    #     return

    results = []
    
    # Initialize CSV file with headers
    with open(OUTPUT_CSV, mode='w', newline='') as csv_file:
        fieldnames = ['slevel', 'time', 'alarms', 'coverage']
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()

        # Main Loop
        for slevel in SLEVEL_LIST:
            exec_time, alarms, coverage = run_analysis(slevel)
            
            row = {
                'slevel': slevel,
                'time': round(exec_time, 4),
                'alarms': alarms,
                'coverage': coverage
            }
            
            # Save data immediately to CSV
            writer.writerow(row)
            csv_file.flush() # Ensure data is written even if script crashes
            results.append(row)

    plot_results(results)

if __name__ == "__main__":
    main()